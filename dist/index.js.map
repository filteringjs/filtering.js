{"version":3,"file":"index.js","mappings":"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","sources":["webpack://filteringjs/webpack/universalModuleDefinition","webpack://filteringjs/webpack/bootstrap","webpack://filteringjs/webpack/runtime/define property getters","webpack://filteringjs/webpack/runtime/hasOwnProperty shorthand","webpack://filteringjs/webpack/runtime/make namespace object","webpack://filteringjs/./src/result.ts","webpack://filteringjs/./src/utils.ts","webpack://filteringjs/./src/filtering.ts","webpack://filteringjs/./src/schema.ts","webpack://filteringjs/./src/parser.ts","webpack://filteringjs/./src/helper.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"filteringjs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"filteringjs\"] = factory();\n\telse\n\t\troot[\"filteringjs\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {Filter, Group, Item, Schema} from \"./schema\";\n\nexport class Result {\n    readonly #schema: Schema;\n    readonly #groups = new Map<string, GroupResult>();\n\n    readonly #filteredItems = new Set<Item>();\n    readonly #allItems = new Set<Item>();\n\n    constructor(schema: Schema) {\n        this.#schema = schema;\n\n        this.#initialize();\n    }\n\n    #initialize() {\n        for (const group of this.schema.groups) {\n            const groupResult = new GroupResult(group);\n            for (const filter of group.filters) {\n                const filterResult = new FilterResult(filter);\n                groupResult.addFilter(filterResult);\n            }\n            this.addGroup(groupResult);\n        }\n    }\n\n    get schema(): Schema {\n        return this.#schema;\n    }\n\n    get groups(): GroupResult[] {\n        return [...this.#groups.values()];\n    }\n\n    get groupNames(): string[] {\n        return [...this.#groups.keys()];\n    }\n\n    addGroup(groupResult: GroupResult) {\n        this.#groups.set(groupResult.schemaGroup.name, groupResult);\n    }\n\n    getGroup(groupName: string) {\n        return this.#groups.get(groupName);\n    }\n\n    get filteredItems() {\n        return [...this.#filteredItems];\n    }\n\n    addFilteredItem(item: Item) {\n        this.#filteredItems.add(item);\n        for (const groupName of item.getGroupNames()) {\n            const groupResult = this.#groups.get(groupName);\n            groupResult.addFilteredItem(item);\n        }\n    }\n\n    get allItems() {\n        return [...this.#allItems];\n    }\n\n    addAllItem(item: Item) {\n        this.#allItems.add(item);\n        for (const groupName of item.getGroupNames()) {\n            const groupResult = this.#groups.get(groupName);\n            groupResult.addAllItem(item);\n        }\n    }\n\n    get possibleItems(): Item[] {\n        const result = new Set<Item>();\n        for (const groupResult of this.groups) {\n            for (const filterResult of groupResult.filters) {\n                for (const item of filterResult.possibleItems) {\n                    result.add(item);\n                }\n            }\n        }\n        return [...result];\n    }\n}\n\nexport class GroupResult {\n    readonly #schemaGroup: Group;\n\n    readonly #filters = new Map<string, FilterResult>();\n\n    readonly #filteredItems = new Set<Item>();\n    readonly #allItems = new Set<Item>();\n\n    constructor(schemaGroup: Group) {\n        this.#schemaGroup = schemaGroup;\n    }\n\n    get schemaGroup(): Group {\n        return this.#schemaGroup;\n    }\n\n    get filters(): FilterResult[] {\n        return [...this.#filters.values()];\n    }\n\n    addFilter(filterResult: FilterResult) {\n        this.#filters.set(filterResult.schemaFilter.name, filterResult);\n    }\n\n    getFilter(filterName: string) {\n        return this.#filters.get(filterName);\n    }\n\n    addFilteredItem(item: Item) {\n        this.#filteredItems.add(item);\n        for (const filterName of item.getFilterNames(this.schemaGroup.name)) {\n            const filterResult = this.#filters.get(filterName);\n            filterResult.addFilteredItem(item);\n        }\n    }\n\n    addAllItem(item: Item) {\n        this.#allItems.add(item);\n        for (const filterName of item.getFilterNames(this.schemaGroup.name)) {\n            const filterResult = this.#filters.get(filterName);\n            filterResult.addAllItem(item);\n        }\n    }\n}\n\nexport class FilterResult {\n    readonly #schemaFilter: Filter;\n\n    readonly #filteredItems = new Set<Item>();\n    readonly #possibleItems = new Set<Item>();\n    readonly #allItems = new Set<Item>();\n\n    constructor(schemaFilter: Filter) {\n        this.#schemaFilter = schemaFilter;\n    }\n\n    get schemaFilter() {\n        return this.#schemaFilter;\n    }\n\n    get filteredItems() {\n        return [...this.#filteredItems];\n    }\n\n    addFilteredItem(item: Item) {\n        this.#filteredItems.add(item);\n    }\n\n    get possibleItems() {\n        return [...this.#possibleItems];\n    }\n\n    addPossibleItem(item: Item) {\n        this.#possibleItems.add(item);\n    }\n\n    get allItems() {\n        return [...this.#allItems];\n    }\n\n    addAllItem(item: Item) {\n        this.#allItems.add(item);\n    }\n}\n","export interface Pojo {\n    [key: string]: any;\n}\n\nexport function findOne<Type>(haystack: Set<Type>, values: Set<Type>) {\n    for (const v of values) {\n        if (haystack.has(v)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function mapProperty(object: any, propertyName: string): any {\n    const parts = propertyName.split('.');\n    let result = object;\n    for (const part of parts) {\n        if (result === undefined) {\n            return undefined;\n        }\n        result = result[part];\n    }\n    return result;\n}\n","import {FilterData, Item, Schema} from \"./schema\";\nimport {FilterResult, GroupResult, Result} from \"./result\";\nimport {findOne} from \"./utils\";\n\nexport class Filtering {\n\n    readonly #schema: Schema;\n    readonly #options: FilteringOptions;\n\n    constructor(data: Schema, options: FilteringOptions = {}) {\n        this.#schema = data;\n        this.#options = options;\n    }\n\n    filter(filterData: FilterData): Result {\n        const result = new Result(this.#schema);\n\n        let relevantItems: Item[] = [];\n        if (this.#options.filterItem) {\n            for (const item of this.#schema.items) {\n                if (this.#options.filterItem(item, this.#schema, filterData)) {\n                    relevantItems.push(item);\n                }\n            }\n        } else {\n            relevantItems = [...this.#schema.items];\n        }\n        for (const item of relevantItems) {\n            result.addAllItem(item);\n        }\n        for (const item of this.#getFilterItems(relevantItems, filterData)) {\n            result.addFilteredItem(item);\n        }\n        this.#calculatePossibleItems(result, relevantItems, filterData);\n\n        return result;\n    }\n\n    #calculatePossibleItems(result: Result, items: Item[], filterData: FilterData) {\n        for (const groupName of result.groupNames) {\n            const possibleFilterData = filterData.clone();\n            possibleFilterData.disableGroup(groupName);\n\n            const filteredItems = this.#getFilterItems(items, possibleFilterData);\n            for (const filteredItem of filteredItems) {\n                for (const filteredItemFilterName of filteredItem.getFilterNames(groupName)) {\n                    result.getGroup(groupName).getFilter(filteredItemFilterName).addPossibleItem(filteredItem);\n                }\n            }\n        }\n    }\n\n    #getFilterItems(items: Item[], filterData: FilterData) {\n        const result = new Set<Item>();\n\n        for (const item of items) {\n            let filtered = true;\n\n            for (const [groupName, checkedFilters] of filterData.checkedFilters) {\n                if (checkedFilters.size > 0 && !findOne(item.getFilterNames(groupName), checkedFilters)) {\n                    filtered = false;\n                    break;\n                }\n            }\n\n            if (filtered) {\n                result.add(item);\n            }\n        }\n\n        return result;\n    }\n}\n\nexport interface FilteringOptions {\n    filterItem?(item: Item, schema: Schema, filterData: FilterData): boolean,\n}\n","import {Pojo} from \"./utils\";\n\nexport class Schema {\n    #groups: Map<string, Group> = new Map();\n    #items: Item[] = [];\n    #data?: Pojo;\n\n    constructor(data?: Pojo) {\n        this.#data = data;\n    }\n\n    get groups(): Group[] {\n        return [...this.#groups.values()];\n    }\n\n    get items(): Item[] {\n        return this.#items;\n    }\n\n    addGroup(group: Group) {\n        if (this.#groups.has(group.name)) {\n            throw new Error(`Group with name ${group.name} already added to schema. Group names have to be unique.`);\n        }\n        this.#groups.set(group.name, group);\n    }\n\n    addItem(item: Item) {\n        this.#items.push(item);\n    }\n\n    addItems(items: Item[]) {\n        for (const item of items) {\n            this.addItem(item);\n        }\n    }\n\n    get data(): Pojo {\n        return this.#data;\n    }\n}\n\nexport class Group {\n    #name: string;\n    #filters: Map<string, Filter> = new Map();\n    #data?: Pojo;\n\n    constructor(name: string, data?: Pojo) {\n        this.#name = name;\n        this.#data = data;\n    }\n\n    get name(): string {\n        return this.#name;\n    }\n\n    get filters(): Filter[] {\n        return [...this.#filters.values()];\n    }\n\n    addFilter(filter: Filter) {\n        if (this.#filters.has(filter.name)) {\n            throw new Error(`Filter with name ${filter.name} already in group ${this.name}. Filter names have to be unique in a Group.`);\n        }\n        this.#filters.set(filter.name, filter);\n    }\n\n    getFilterNames() {\n        return new Set(this.#filters.keys());\n    }\n\n    get data(): Pojo {\n        return this.#data;\n    }\n}\n\nexport class Filter {\n    #name: string;\n    #data?: Pojo;\n\n    constructor(name: string, data?: Pojo) {\n        this.#name = name;\n        this.#data = data;\n    }\n\n\n    get name(): string {\n        return this.#name;\n    }\n\n    get data(): Pojo {\n        return this.#data;\n    }\n}\n\nexport class Item {\n    #data?: Pojo;\n    #groups = new Map<string, Set<string>>();\n\n    constructor(data?: Pojo) {\n        this.#data = data;\n    }\n\n    get data(): Pojo {\n        return this.#data;\n    }\n\n    getGroupNames(): Set<string> {\n        return new Set(this.#groups.keys());\n    }\n\n    addFilter(groupName: string, filterName: string) {\n        const filters = this.#getFiltersFromGroup(groupName);\n        filters.add(filterName);\n    }\n\n    #getFiltersFromGroup(groupName: string) {\n        if (!this.#groups.has(groupName)) {\n            this.#groups.set(groupName, new Set());\n        }\n        return this.#groups.get(groupName);\n    }\n\n    getFilterNames(groupName: string): Set<string> {\n        if (this.#groups.has(groupName)) {\n            return new Set(this.#groups.get(groupName));\n        } else {\n            return new Set();\n        }\n    }\n}\n\nexport class FilterData {\n    #checkedFilters: Map<string, Set<string>> = new Map();\n\n    get checkedFilters() {\n        return this.#checkedFilters;\n    }\n\n    checkFilter(groupName: string, filterName: string): void {\n        const filters = this.#getFiltersFromGroup(groupName);\n        filters.add(filterName);\n    }\n\n    checkAllFilters(groupName: string): void {\n        const filters = this.#getFiltersFromGroup(groupName);\n        filters.clear();\n    }\n\n    #getFiltersFromGroup(groupName: string): Set<string> {\n        if (!this.#checkedFilters.has(groupName)) {\n            this.#checkedFilters.set(groupName, new Set());\n        }\n        return this.#checkedFilters.get(groupName);\n    }\n\n    disableGroup(groupName: string): void {\n        this.#checkedFilters.delete(groupName);\n    }\n\n    clone(): FilterData {\n        const filterData = new FilterData();\n        for (const [groupName, filterNames] of this.#checkedFilters.entries()) {\n            for (const filterName of filterNames) {\n                filterData.checkFilter(groupName, filterName);\n            }\n        }\n        return filterData;\n    }\n}\n","import {Filter, FilterData, Group, Item, Schema} from \"./schema\";\n\nexport interface ParserOptions {\n    groupClass?: string,\n    filterClass?: string,\n    itemClass?: string,\n    itemFilterNameAttributePrefix?: string,\n    filterCheckedClass?: string,\n}\n\nexport class Parser {\n\n    static readonly #defaultOptions: ParserOptions = {\n        groupClass: 'filtering-group',\n        filterClass: 'filtering-filter',\n        itemClass: 'filtering-item',\n        itemFilterNameAttributePrefix: 'data-filter',\n        filterCheckedClass: 'checked',\n    }\n\n    readonly #options: ParserOptions;\n\n    constructor(options: ParserOptions = {}) {\n        this.#options = {...Parser.#defaultOptions, ...options};\n    }\n\n    get options(): ParserOptions {\n        return this.#options;\n    }\n\n    parseSchemaFromHtml(element: HTMLElement, schema: Schema = new Schema()) {\n        this.parseGroupsAndFiltersFromHtml(element, schema);\n        for (const item of this.parseItemsFromHtml(element)) {\n            schema.addItem(item);\n        }\n        return schema;\n    }\n\n    parseGroupsAndFiltersFromHtml(element: HTMLElement, schema: Schema) {\n        for (const groupElement of element.getElementsByClassName(this.#options.groupClass) as HTMLCollectionOf<HTMLElement>) {\n            const groupName = groupElement.dataset.groupName;\n            if (groupName === undefined) {\n                continue;\n            }\n            const group = new Group(groupName, {\n                element: groupElement,\n                label: groupElement.dataset.groupLabel,\n            });\n\n            for (const filterElement of groupElement.getElementsByClassName(this.#options.filterClass) as HTMLCollectionOf<HTMLElement>) {\n                const filterName = filterElement.dataset.filterName;\n                if (filterName === undefined) {\n                    continue;\n                }\n                const filter = new Filter(filterName, {\n                    element: filterElement,\n                    label: filterElement.dataset.filterLabel,\n                });\n\n                group.addFilter(filter);\n            }\n            schema.addGroup(group);\n        }\n    }\n\n    parseItemsFromHtml(element: HTMLElement) {\n        const items: Item[] = [];\n\n        const attributeRegex = new RegExp(`${this.#options.itemFilterNameAttributePrefix}-(?<groupName>.+)`, 'i');\n        for (const itemElement of element.getElementsByClassName(this.#options.itemClass) as HTMLCollectionOf<HTMLElement>) {\n            const item = new Item({\n                element: itemElement\n            });\n            for (const {name: attributeName, value: filterNames} of itemElement.attributes) {\n                const match = attributeName.match(attributeRegex);\n                if (match) {\n                    const {groupName} = match.groups;\n                    for (const filterName of filterNames.split(/\\s*,\\s*/)) {\n                        item.addFilter(groupName, filterName);\n                    }\n                }\n            }\n            items.push(item);\n        }\n        return items;\n    }\n\n    parseCheckedFilterDataFromHtml(element: HTMLElement) {\n        const filterData = new FilterData();\n        for (const groupElement of element.getElementsByClassName(this.#options.groupClass) as HTMLCollectionOf<HTMLElement>) {\n            const groupName = groupElement.dataset.groupName;\n\n            for (const filterElement of groupElement.getElementsByClassName(this.#options.filterClass) as HTMLCollectionOf<HTMLElement>) {\n                const filterName = filterElement.dataset.filterName;\n\n                if (filterElement.classList.contains(this.#options.filterCheckedClass)) {\n                    filterData.checkFilter(groupName, filterName);\n                }\n            }\n        }\n        return filterData;\n    }\n}\n","import {Schema} from \"./schema\";\nimport {Parser, ParserOptions} from \"./parser\";\nimport {Filtering, FilteringOptions} from \"./filtering\";\n\nexport class FilteringFlow {\n\n    readonly options: FilteringFlowOptions;\n    static readonly defaultOptions: FilteringFlowOptions = {\n        triggerFilterAfterInitializing: true,\n        disabledFilterClass: 'disabled',\n        filteredItemClass: 'filtered',\n    }\n\n    readonly root: HTMLElement;\n    schema: Schema;\n    parser: Parser;\n    filtering: Filtering;\n\n    constructor(root: HTMLElement, options: FilteringFlowOptions = {}) {\n        this.root = root;\n        this.options = {...FilteringFlow.defaultOptions, ...options};\n\n        this.initializeParser();\n        this.initializeSchema();\n        this.initializeFiltering();\n        this.initializeFilterListener();\n\n        if (this.options.triggerFilterAfterInitializing) {\n            this.filter();\n        }\n    }\n\n    initializeParser(parserOptions?: ParserOptions) {\n        this.parser = new Parser(parserOptions);\n        return this.parser;\n    }\n\n    initializeSchema() {\n        this.schema = this.parser.parseSchemaFromHtml(this.root);\n        return this.schema;\n    }\n\n    initializeFiltering(filteringOptions?: FilteringOptions) {\n        this.filtering = new Filtering(this.schema, filteringOptions);\n        return this.filtering;\n    }\n\n    initializeFilterListener() {\n        for (const filterElement of this.root.getElementsByClassName(this.parser.options.filterClass) as HTMLCollectionOf<HTMLElement>) {\n            filterElement.addEventListener('click', (event) => {\n                event.preventDefault();\n                if (filterElement.classList.contains(this.options.disabledFilterClass)) {\n                    // Ignore click if the filter would give 0 results\n                    return;\n                }\n                if (this.beforeFilter(filterElement)) {\n                    filterElement.classList.toggle(this.parser.options.filterCheckedClass); // Check or uncheck filter\n                    this.filter();\n                }\n            });\n        }\n    }\n\n    beforeFilter(filterElement: HTMLElement) {\n        return true;\n    }\n\n    filter() {\n        // Parse checked filter from HTML\n        const filterData = this.parser.parseCheckedFilterDataFromHtml(this.root);\n        const result = this.filtering.filter(filterData);\n        for (const group of result.groups) {\n            for (const filter of group.filters) {\n                const filterElement = filter.schemaFilter.data.element;\n                // Disable filter if it would give 0 results\n                filterElement.classList.toggle(this.options.disabledFilterClass, filter.possibleItems.length === 0);\n            }\n        }\n        for (const item of result.allItems) {\n            // Show or hide items\n            item.data.element.classList.toggle(this.options.filteredItemClass, !result.filteredItems.includes(item));\n        }\n        return result;\n    }\n}\n\ninterface FilteringFlowOptions {\n    disabledFilterClass?: string,\n    filteredItemClass?: string,\n    triggerFilterAfterInitializing?: boolean,\n}\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Result","Map","Set","constructor","schema","group","groups","groupResult","GroupResult","filter","filters","filterResult","FilterResult","addFilter","addGroup","values","groupNames","keys","set","schemaGroup","name","getGroup","groupName","filteredItems","addFilteredItem","item","add","getGroupNames","allItems","addAllItem","possibleItems","result","schemaFilter","getFilter","filterName","getFilterNames","addPossibleItem","findOne","haystack","v","has","Filtering","data","options","filterData","relevantItems","filterItem","items","push","possibleFilterData","clone","disableGroup","filteredItem","filteredItemFilterName","filtered","checkedFilters","size","Schema","Error","addItem","addItems","Group","Filter","Item","FilterData","checkFilter","checkAllFilters","clear","delete","filterNames","entries","Parser","static","groupClass","filterClass","itemClass","itemFilterNameAttributePrefix","filterCheckedClass","parseSchemaFromHtml","element","parseGroupsAndFiltersFromHtml","parseItemsFromHtml","groupElement","getElementsByClassName","dataset","undefined","label","groupLabel","filterElement","filterLabel","attributeRegex","RegExp","itemElement","attributeName","attributes","match","split","parseCheckedFilterDataFromHtml","classList","contains","FilteringFlow","triggerFilterAfterInitializing","disabledFilterClass","filteredItemClass","parser","filtering","defaultOptions","initializeParser","initializeSchema","initializeFiltering","initializeFilterListener","parserOptions","filteringOptions","addEventListener","event","preventDefault","beforeFilter","toggle","length","includes"],"sourceRoot":""}